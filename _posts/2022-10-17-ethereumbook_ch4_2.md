---
layout: post                           # (require) default post layout
title: "마스터링 이더리움 ch4_2"            # (require) a string title
date: 2022-10-17 19:00:00 +0900        # (require) a post date
categories: [all, ethereum, blockchain, 마스터링 이더리움]  # (custom) some categories, but makesure these categories already exists inside path of `category/`
---

# 마스터링 이더리움 ch4 암호학
'마스터링 이더리움 스마트 컨트랙트 및 댑 구축하기' 책의 세미나   
제 4장 이더리움 암호학   
이더리움 프로토콜의 어느 부분도 암호화되어 있지 않음      

향후 영지식 증명(zero knowledge proof)과 동형암호(homomorphic encryption) 같은 고급 암호화 도구 사용하여 여전히 합의 가능하게 하면서도 암호화된 계산을 블록체인에 기록
⇒ 준비는 마쳤으나 아직 배포되지는 않음
* 영지식증명(zero knowledge proof)
  * 암호학에서 누군가가 상대방에게 어떤 상태가 참이라는 것을 증명할 때, 그 문장의 참 거짓 여부를 제외한 어떤 것도 노출되지 않도록 하는 절차
  * 영지식 증명을 활용한 프로토콜의 가장 큰 특징은 정보를 공개하지 않고 정보의 ‘유효성'을 증명할 수 있는 방법
  * 편의점 등에서 이름/생년월일을 알리지 않고 성년임을 증명
* 동형암호(homomorphic encryption)
  * 데이터를 암호화된 상태에서 연산할 수 있는 암호화 방법
  * 암호문들을 이용한 연산의 결과는 새로운 암호문이 되며, 이를 복호화하여 얻은 평문은 암호화하기 전 원래 데이터의 연산 결과와 같음
  * 개인정보 노출 없이 암호문을 연산하여 다시 암호문을 생성
  
## 키와 주소
디지털 개인키(private key), 이더리움 주소(Ethereum address), 디지털 서명(digital signature)을 통해 외부 소유 계정(Externally Owned Account, EOA)의 이더 소유권 확립
* 개인키
  * 계정(account)이라 불리는 이더리움 주소를 고유하게 결정
  * 이더리움에 전송하지 않음
  * 이더리움 블록체인에 저장하지 않음
  * 비공개로 유지되어야 함
  * 해당 계정과 해당 계정이 가진 이더 제어
  * 암호화된 특수 파일에 저장
  * 이더리움 지갑 소프트웨어로 관리
* 이더리움 주소
  * 이더리움 수신자를 표시
  * 은행 계좌 정보와 동일
  * 외부 소유 계정의 이더리움 주소는  공개키-개인키 쌍의 공개키 부분에서 생성
  * 컨트랙트 주소는 개인키로 뒷받침되지 않음
* 디지털 서명
  * 디지털 서명을 사용하여 자금의 접근과 통제
  * 이더리움에 전송
  * 이더리움 블록체인에 저장
  * 트랜잭션에 저장되어 개인키 소유권을 증명

## 공개키 암호화와 암호화폐
* 공개키 암호화는 고유한 키를 사용하여 정보를 보호
* 이 키는 특수한 속성(계산하기는 쉽지만 그 역(inverse)을 계산하기는 어렵다)을 가진 수학 함수를 바탕으로 함
* 디지털 비밀과 위조불가능한 디지털 서명을 만들 수 있음
* 수학 법칙에 의해 보장
* 트랩 도어 함수(trapdoor function,비밀통로 일방향함수)
  * 일방향함수의 한 종류
  * 보통 일방향함수처럼 함수의 역을 구하는 것은 어렵지만, 트랩도어라고 부르는 특수한 정보가 있으면 쉽게 역을 구할 수 있는 함수
  * 암호학 분야에서 널리 사용
* 이산 로그 문제(discrete logarithm problem)
  * 소수로 나눈 나머지를 곱하는 것은 간단하지만, 나눗셈(역함수)은 사실상 불가능
  * 이산로그는 일반 로그와 비슷하게 군론에서 정의된 연산으로, ax = b를 만족하는 정수 x(=이산 대수)

## 개인키
* 단순히 무작위로 선택한 숫자
* 이더리움 모든 자금에 대한 사용자 제어의 근원
* 항상 비밀로 유지해야 함
* 반드시 백업하여 우발적인 손실로부터 보호해야 함
* 한번 잃어버리면 되찾을 수 없으며, 해당 키로 확보한 자금도 영원히 잃어버림
* 난수로 개인키 생성
  * 개인키 생성의 가장 중요한 첫 번째 단계는 엔트로피, 즉 무작위성을 확보하는 것
  * 256 비트 숫자를 무작위로 추출 ⇒ 유효한 범위 확인 ⇒ 프로그램 측면에서 일반적으로 임의의 비트 문자열(암호학적으로 안전한 임의성 소수에서 수집됨)을 Keccak-256또는 SHA-256 같은 256비트 해시 알고리즘에 공급
  * 간단한 난수 발생기를 사용하지 말고 충분한 엔트로피 원천의 시드(seed)와 함께 암호로 안전한 의사 난수 생성기(CSPRNG)를 사용할 것
  
## 공개키
* 타원 곡선 암호화 설명
  * 타원 곡선 암호화는 타원 곡선의 점에 더하기와 곱셈으로 표현되는 이산 대수 문제를 바탕으로 한 비대칭 또는 공개키 암호화 유형
  * 비트코인과 같이 secp256k1이라는 정확한 타원 곡선을 사용
    * 미국 표준 기술 연구소(US National Institute of Standards and Technology (NIST))에서 정의
    * 실수 대신에 소수 위수의 유한체 상에 정의, 정수   
  
![그림1](https://raw.githubusercontent.com/hanscom95/hanscom95.github.io/master/static/img/_posts/bitcoinbook_ch4_2.png)   
그림1 타원 곡선 함수 계산 과정

* 타원 곡선 산술 연산
  * 더하기 연산자 정의: 숫자 선을 따라 점프하는 대신 곡선의 다른 점으로 점프
  * 점과 정수의 곱셈 정의: 반복되는 덧셈
  * 타원 곡선에서 두 점 P1과 P2가 주어지면 세 번째 점 P3 = P1 + P2가 타원 곡선에 있도록 덧셈을 정의
  * P1 과 P2를 이어 선을 그으면 추가 장소는 타원 곡선과 교차, P’3 = (x, y)
  * P’3 을 x 축에 반사하여 P3를 구함. P3 = (x, -y)
  * 무한원점(책에는 무한대점으로 표현)
    * 대략 0의 역할, y 좌표가 무한대(∞)인 점
    * P3이 무한원점인 경우: P1과 P2의 x값이 동일하고 y 값이 다르면 선이 정확히 수직
    * P1이 무한원점인 경우: P1 + P2 = P2
    * P2가 무한원점인 경우: P1 + P2 = P1 
  * 덧셈의 결합 법칙
    * (A + B) + C = A + (B + C) = A + B + C
  * 곱셈
    * 타원 곡선 상의 점 P에 대해 k가 정수이면 k * P = P + P + P + … + P(k번 반복)
    * 이 경우 k는 때때로 지수(exponent)라고도 함
  
![그림2](https://raw.githubusercontent.com/hanscom95/hanscom95.github.io/master/static/img/_posts/ethereumbook_ch4_1.png)
* 공개키 생성
  * 무작위로 생성한 숫자 k 형태의 개인키로 시작해서 생성자 점(generator point) G라고 하는 곡선의 미리 결정된 점에 개인키를 곱하여 곡선상의 다른 점, 즉 대응하는 공개키 K를 생성
  * K = k * G(타원 곡선 곱셈)
  * 생성자 점은 secp256k1의 표준 일부로 지정
  * G는 모든 이더리움 사용자에 대해 동일
  * G와 개인키 k를 곱한 결과는 항상 공개키 K로 동일
  * k에서 K까지는 한 방향으로만 계산할 수 있음
* 타원 곡선 라이브러리
  * OpenSSL
    * OpenSSL 전체 구현을 포함하여 포괄적인 암호학적 기반 요소를 제공
    * 공개키를 생성하려면 EC_POINT_mul 함수를 사용
  * libsecp256k1
    * 비트코인 코어에서 타원 곡선 및 기타 암호화 기초 요소를 C로 구현
    * 비트코인 코어에서 OpenSSL을 대체하기 위해 완전히 새로 작성
    * 성능과 보안 면에서 모두 뛰어남

## 암호화 해시 함수
* 암호학자 브루스 슈나이어(Bruce Schneier): 암호화 알고리즘보다 단방향 해시 함수들이 현대 암호화를 더 잘 이끄는 견인차
* 이더리움 사용처: 공개키를 주소로 변환, 디지털 지문(digital finterpints) 생성
* 임의의 크기의 데이터를 고정된 크기의 데이터로 매핑하는 데 사용되는 모든 함수
* 다대일 함수 ⇒ 해시 충돌(hash collision) 발생, 해시 함수가 좋을수록 해시 충돌이 덜 발생
* 이더리움에서는 사실상 해시 충돌이 불가능
* 암호화 해시 함수 속성
  * 결정론(Determinism)
    * 주어진 입력 메시지는 항상 동일한 해시 결과를 생성
  * 검증성(Verifiability)
    * 메시지의 해시 계산은 효율적(선형 복잡성)
  * 비상관성(Noncorrelation)
    * 메시지에 대한 작은 변화(예: 1비트 변화)는 해시 출력을 광범위하게 변경해야 해서 원본 메시지의 해시와 상관 관계가 없음
  * 비가역성(Irreversibility)
    * 해시로부터 메시지를 계산하는 것은 불가능, 모든 가능한 메시지에 대한 무차별 검색(brute-force search)과 같음
  * 충돌방지(Collision protection)
    * 같은 해시 결과를 생성하는 2개의 서로 다른 메시지를 계산하는 것은 불가능
* 이더리움 사용처
  * 데이터 핑거프린팅
  * 메시지 무결성(오류 감지)
  * 작업증명
  * 인증(암호 해싱 및 키 스트레칭)
  * 의사 난수 생성기
  * 메시지 커밋(커밋-공개 메커니즘)
  * 고유 식별자
* 이더리움 암호화 해시 함수: Keccak-256
  * 2007년 미국 국립 과학 기술 연구소(National Institute of Standards and Technology, NIST)에서 개최한 SHA-3 암호화 해시 경쟁 대회 우승 알고리즘
  * 2015년 FIPS(Federal Information Processing Standard) 202로 표준화
  * NIST가 파라미터 조정 ⇒ 백도어 탑재(에드워드 스노든 폭로)
  * 이더리움 재단은 수정된 SHA-3이 아닌 원래 Keccak 알고리즘을 구현

## 이더리움 주소
* 타원 곡선 곱셈을 사용해서 만든 공개키를 keccack-256 해시 함수로 생성한 고유 식별자(unique identifiers)
* 개인키 k: 난수를 사용하여 생성
* 공개키 K: 개인키로 타원 곡선 곱셈을 사용해서 생성
* 이더리움 주소 생성1: 공개키를 Keacck-256 해시 함수로 해시 계산
* 이더리움 주소 생성2: 마지막 20바이트(최하위 바이트)만 유지
* 이더리움 주소 형식
  * 공개키 Keacck-256 해시의 마지막 20바이트에서 파생한 식별자
  * 잘못된 주소를 보호하는 체크섬을 사용하는 비트코인과 달리 체크섬이 없는 원시 16진수 ⇒ 시스템의 상위 계층에서 추상화(예: 이름 서비스)에 숨겨지고 필요하면 상위 계층에서 체크섬을 추가해야 함
  * 상위 계층이 너무 늦게 개발되었음
  * 잘못 입력한 주소 및 입력 유효성 오류로 인한 자금 손실 등 생태계 초기에 여러 가지 문제를 발생시켰음
  * 이더리움 이름 서비스가 처음 예상보다 늦게 개발되었기 때문에 지갑 개발자는 대체 인코딩을 매우 천천히 채택
* 클라이언트 주소 상호 교환 프로토콜
  * Inter exchange Client Address Protocol(ICAP)
  * IBAN(international standard for identifying bank account numbers, 국제 은행 계좌 번호) 인코딩과 부분적으로 호환되는 이더리움 주소 인코딩
  * 이더리움 주소에 대해 다목적의 체크섬이 가능하고 상호운용 가능한 인코딩을 제공
  * ICAP 주소는 이더리움 이름 레지스트리에 등록한 이더리움 주소 또는 일반 이름을 인코딩할 수 있음
  * ICAP의 IBAN 호환성
    * 이더리움을 나타내는 비표준 국가 코드 ‘XE’를 도입한 후 두 문자 체크섬과 계정 식별자의 세 가지를 가능한 변형을 도입하여 동일한 구조를 사용
    * 몇 가지 지갑에서만 지원
  * ICAP의 세 가지 변형
    * 직접(Direct)
      * 이더리움 주소의 최하위 비트 155개를 나타내는 최대 30자의 영숫자로 구성된 빅엔디안(big endian) base36 정수
      * 일반 이더리움 주소의 전체 160바이트보다 적기 때문에 하나 이상의 0바이트로 시작하는 이더리움 주소에서만 동작
      * 장점: 필드 길이와 체크섬 측면에서 IBAN과 호환
      * 예: XE60HAMICDXSV5QXVJA7TJW47Q9CHWKJD(길이: 33자)
    * 기본(Basic)
      * 직접 인코딩과 동일하지만 길이는 31자
      * 이더리움 주소를 인코딩할 수 있지만 IBAN 필드 유효성 검사와 체크섬 검사와 호환되지 않음
      * 예: XE18CHDJBPLTBCJ03FE9O2NS0BPOJVQCU2P(길이: 35자)
    * 간접(Indirect)
      * 이름 레지스터 공급자를 통해 이더리움 주소로 확인되는 식별자를 인코딩
      * 자신 식별자(asset identifier, 예: ETH), 이름 서비스(예: XREG) 및 사람이 읽을 수 있는 9자 이름(예: KITTYCATS)으로 구성된 16개의 영숫자를 사용
      * 예: XE##ETHXREGKITTYCATS(길이: 20자), ##는 계산된 체크섬 문자로 대체해야 함
  * ICAP 주소 추출
    ```shell
    $ sudo npm install -g helpeth
    $ helpeth keyDetails -p 0xf8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
    Address: 0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9
    Address (checksum): 0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
    ICAP: XE60 HAMI CDXS V5QX VJA7 TJW4 7Q9C HWKJ D
    Public key: 0x6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
    ```
* 대문자로 16진수 인코딩된 체크섬(EIP-55)
  * ICAP과 네임 서비스의 느린 배포로 EIP-55에서 표준을 제안
  * 16진수 주소의 대소문자를 수정하여 이더리움 주소에 대해 이전 버전과 호환되는 체크섬 제공
  * 이더리움 주소는 대소문자를 구분하지 않으므로 모든 지갑은 대문자 또는 소문자로 표현된 이더리움 주소를 수용해야 함
  

## 타원 곡선 함수 보충
* 타원 곡선 함수(Elliptic Curve Cryptography, ECC)
  * 1985년, RSA 암호의 대안으로 고안
  * 짧은 키 길이와 빠른 연산, 동일한 보안 강도를 제공( RSA 1024 비트와 ECC 160 비트가 동일 보안 강도)
  * 바이어슈트라스 표준형: 소수 p가 2와 3이 아닐 때 y2 = x3 + ax + b(2와 3은 유의미한 공격법이 존재)
* 타원 곡선 함수 덧셈의 정의 1
  * 타원 곡선에서 점의 덧셈은 점을 직선으로 이었을 때 나오는 모양에 따라 정의
  * 타원 곡선을 지나는 모든 직선의 타원 곡선과의 교점을 모두 더하면 무한원점(O)이 됨(P + Q + R = O)
  * 타원 곡선 위의 두 점 P과 Q를 잇는 직선이 보여주는 모양은 다음과 같은 4가지 경우
* 타원 곡선의 성질
  * 덧셈에 대해 닫힘: 점 P와 Q가 타원 곡선 위에 있을 때, P + Q 또한 타원 곡선 위에 있다.
  * 항등원의 존재: 타원 곡선 위의 임의의 점 P에 대해 P + O = P가 성립한다.
  * 덧셈의 교환법칙, 결합법칙: 타원 곡선 위의 임의의 점 P, Q, R에 대해 P + (Q + R)=(P + Q) + R이 성립하고, 타원 곡선 위의 임의의 점 P, Q에 대해 P + Q = Q + P가 성립한다.
  * 역원의 존재: 모든 점 P에 대해 −P가 존재하고 P + (−P) = O이 성립한다
* 타원 곡선 함수 덧셈의 정의 2 및 곱셈
  * P + Q + R = O
  * P + Q = -R
  * 곱셈은 덧셈을 반복


